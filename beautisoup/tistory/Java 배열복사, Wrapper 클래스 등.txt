1. Math.random() vs java.util.Random 1-1 사실 둘 모두 동일하다. Math.random() 함수가 내부적으로 java.util.Random 클래스를 사용한다. 2. 배열 복사 2-1 System.arraycopy(복사대상 배열, 시작 인덱스, 복제 배열, 시작 인덱스, 복사할 개수) 2-2 arraycopy는 swallow copy이기 때문에 primitive type만 복사하는 것이 편리하다. 2-3 for 루프로 각각 복사할 필요가 없다. 사실 stream을 사용하면 간단하게 복사 가능하다. 3. design by contract 3-1 Bertrand Meyer의 오래된 객체지향 설계컨셉이다. 97년 Object-Oriented Software Construction 2판에 수록됨 3-2 Brad Cox의 86년 Object-Oriented Programming: An Evolutionary Approach에 producer, consumer가 등장 3-2-1 producer는 서비스를 제공하는 클래스의 책임을 가지고 있고, 3-2-2 consumer는 서비스를 사용하는 측의 책임을 가진다. 3-2-3 책임이라는 것은 각각의 위치에서 계약으로 설정된 것으로 간주할 수 있는 부분이다. 3-2-3-1 만일, stack을 생각하면 consumer에서 pop을 할 때 반드시 stack이 비어있는지를 확인해야 한다. 3-2-3-2 producer의 책임은 pop이 실행된 후 내부적인 상태값을 변경하는 것이다. 즉 총 저장개수가 1 줄어야 한다. 3-2-4 즉 각각의 파트에서 contract라고 할 수 있는 기본적인 책임을 다 해야만 정상적으로 동작한다. 3-2-4-1 자바의 Stack 클래스 소스를 보면 pop할 때 stack이 비었는지 확인하지 않고 비었을 경우 예외가 발생한다. 3-3 자바의 기본 설계가 design by contract를 기반하기 때문에 consumer의 책임을 명확하게 아는 것이 중요하다. 3-3-1 이런 책임에 대한 부분은 주석에 많이 적혀져 있다. 4. Primitive Type은 각각 Wrapping 클래스를 가지고 있다. 4-1 이전에는 Wrapping 클래스를 생성할 때는 new Integer(10)  이런 식으로 생성했지만, 지금은 valueOf를 권장한다. 4-1-1 Integer.valueOf(10) 이런 식으로 하면 Integer 객체가 반환된다. 4-2 예전엔 String을 숫자 primitive로 변환할 때 (new Integer(str)).intValue()를 사용했지만 parseInt를 권장한다. 4-2-1 Integer.parseInt(str) 이나 Double.parseDouble(str) 를 사용하면 primitive type이 반환된다. 5. JDK 1.2에서 Vector와 StringBuffer는 유사한 기능을 가진 ArrayList, StringBuilder로 변경되었다. thread-safety 차이다. 5-1 Java Collections framework가 JDK1.2에서 도입되면서 생성된 라이브러리는 모두 thread safe 하지 않다. 5-2 대신 synchronized가 없기 때문에 속도가 훨씬 빠르다. 5-3 concurrency가 중요한 경우는 예전의 라이브러리를 사용하는 것이 안전하다.