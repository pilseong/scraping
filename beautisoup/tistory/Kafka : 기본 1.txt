1. 카프카는 메시지 브로커이다. 2. 데이터 소스에서 발생한 데이터를 취합하고 저장하여 많은 타겟 시스템에 제공하는 것이 주요 기능이다. 2-1 통신 프로토콜, 데이터 포멧, 데이터 스키마의 제약과 서버의 부하에 대한 대안으로 제안된 기술이다. 3. 속도가 빠르다, 확장성이 좋다, 분산형이다. 복구가 쉽고, 장애 처리에 유리하다. 이런 건 당연한 내용이다. 4. 용도 4-1 메시지 시스템 4-2 실시간 활동 추적 (데이터를 실시간으로 받아서 계속 모니터링 가능하다) 4-3 다양한 장소로 부터 다양한 정보를 축척 4-4 로그 정보 저장 4-5 Streaming processing (이건 실시간 정보처리인데 reactive programming에 유리하다.) 4-6 시스템 의존성을 줄일 수 있다. 4-7 Spark, Flink, Storm, Hadoop 같은 많은 빅데이터 기술과 연결할 수 있다. 5. 기술 용어 5-1 Topic : 하나의 데이터 축적을 위한 주제. 데이터베이스의 테이블이라고 생각하면 된다. 5-1-1 특정한 정보를 저장하는 단위이다. 즉 택배번호를 저장하거나 택배의 위치를 정보를 저장하거나 그런 식이다. 5-1-2 이런 동일한 정보가 여러개의 파티션에 나누어 저장된다고 생각하면 된다. 5-2 Partition : 하나의 토픽을 저장하는데 사용하는 여러 개의 통로라고 생각하면 된다. 5-2-1 순서가 있고, 각 파티션에 저장되는 메시지도 순서를 가진다. 5-2-2 메시지는 동일한 파티션에 존재할 때 순서가 보장된다. 각 메시지는 테이블의 id 같이 고유의 id를 가진다. 5-2-3 저장되면 절대로 변경되지 않는다. (immuability) 5-2-4 파티션 할당은 저장시 key가 주어지는 경우에는 특정 파티션에 저장되지만 없으면 round robin 방식으로 저장 5-3 Offset : 이건 메시지 id라고 생각하면 된다. 위의 그림에서 Partition 내의 번호가 Offset이다. 5-3-1 이 정보는 특정 파티션 안에서만 의미가 있고, 순서가 보장된다. 5-4 Broker : 카프카는 클러스터라는 브로커의 그룹으로 구성되는데 브로커는 하난의 서버라고 보면 된다. 5-4-1 아래를 보면 3개의 브로커가 하나의 클러스터를 구성한다. Topic1도 3개의 파티션을 가지고 있다. 5-4-2 3개의 브로커에 하나의 토픽의 파티션들이 분산되어 있다. 이것은 장애처리 복구를 위한 것이다. 5-4-3 각 브러커도 고유의 id가 존재한다. 5-4-4 클라이언트가 어떤 브로커에 붙어도 클러스터 전체에 접속한 것과 동일하다. 5-4-5 보통 3개의 브로커로 시작하는 것이 적합하다. 5-4-6 만약 2개의 토픽이 있고 각 3개와 2개의 파티션이 있는 경우는 아래와 같이 할당될 수 있다. 5-5 Replication : 이것은 말그대로 데이터를 중복해서 가질 수 있다는 의미이다. 5-5-1 하나의 브로커가 죽어도 다른 서버에서 죽은 브로커의 파티션들을 다른 브로커에서 서비스 할 수 있게 한다. 5-5-2 이렇게 동작하기 위해서는 서버간의 데이터 복사와 동기화가 필요하다. 5-5-3 Replication factor라는 것이 있는데 얼마나 많은 브로커에 복사를 해놓을지를 결정한다. 5-5-3-1 아래의 그림은 replication factor가 3이다. 3개의 카피가 3개의 브로커에 같이 저장되어 있다. 5-5-4 Leader : 파티션의 정보를 실제로 서비스를 제공하는 브로커이다. 나머지는 ISR (in-sync replica) 동기화 복제 5-5-5 Leader만이 특정 파티션의 정보를 받고 서비스 할 수 있는데, 얘가 죽으면 다른 놈이 Leader 된다. 5-5-6 복제의 방법은 데이터를 Leader 받으면 저장하고 factor만큼 다른 브로커에 동기화 복제를 만든다. 5-6 Producer : 이것은 토픽에 데이터를 저장하는 것들이다. 5-6-1 프로듀서는 어떤 브로커에 어떤 파티션에 저장할지를 미리 알고 있다. 5-6-2 브로커가 죽은 경우, 프로듀서는 자동으로 리더로 지정된 다른 놈에게 데이터를 저장한다. 5-6-3 프로듀서는 저장 확인을 하는데 acks설정에 따라서 확인을 받을 것인지를 결정한다. 5-6-3-1 acks=0이면 안받는다. acks=1이면 리더가 저장한 것만 받는다. acks=all이면 복제를 포함하여 다 받는다. 5-6-3-2 중요한 것 acks를 많이 받을 수록 데이터 손실의 확율이 줄어든다. 5-6-4 Message key : 이건 프로듀서가 메시지와 함께 보내는 정보이다. 이것에 따라 어떤 브로커에 저장할지를 결정 5-6-4-1 key=null 이면 뺑뺑이 방식이다. 5-6-4-2 키가 정해져 있으면 특정키는 무조건 동일한 파티션에 저장된다. 5-6-4-2-1 즉 송장정보를 key라고 하면 그 배송정보는 한 파티션에만 저장된다. 5-6-4-3 특정한 브로커에 저장된다는 것이지 그 브로커가 어떤 놈인지는 알 수가 없다. 5-6-4-4 당연하겠지만 내부적으로 key hashing을 사용한다.