1. 코틀린은 자바를 기반하고 있기 때문에 toString(), equals(), hashCode() 메소드를 기본적으로 제공한다. 코틀린의 기본 클래스는 Any로 자바와 차별화를 시도하고 있는데, 사실 코드는 별차이가 없다. 2. 그런데 문제는 코틀린의 equals, hasCode는 생각하고는 다르게 동작한다. 여기에 ==, === 가 더해지면 더 이상 공부하기 싫어진다. 그래서 여기에 메모해 둔다. 3. 상속받은 equals 기본 동작은 객체의 주소 값의 비교이다. 이것은 코틀린의 == 이 수행 되었을 때 동작과 일치한다. 3-1 == 는 기본적으로 객체의 주소값을 비교하여 일치값을 판단한다. 3-2 코틀린에서 객체의 값을 비교하고 싶을 때는 별 수 없이 생성한 클래스의 equals를 override 할 수 밖에 없다. 4. 상속받은 hashCode() 기본 동작 역시 객체의 주소 값을 가지고 Int 값을 생성한다. 모든 속성이 같은 객체라고 하더라도 기본 hashCode의 리턴 값은 다르다. 5. 문제는 String 클래스인데, 이건 동작이 또 다르게 보인다. 사실 동일하다. 5-1 다르게 보이는 가장 큰 이유는 문자열 풀 때문인데, String a = " ... "  이런 식으로 정의한 문자열은 기본적으로 코틀린 문자열 풀에 들어가서 같은 문자열은 동일한 주소를 가진다. 그렇기 때문에 이런 식으로 동일한 문자열을 대입한 두개의 다른 변수의 equas, == 비교는 항상 true를 반환한다. 5-2 물론 생성자를 통해서 생성한 문자열은 heap에 생성되기 때문에 별도의 객체 주소를 가지기 때문에 이 경우는 equals, == 의 결과는 항상 false가 된다. 5-3 문자열과 객체를 묶어서 생각하면 헷길릴 수 밖에 없다. String은 별도로 생각하고 객체는 그냥 heap에 생성되는 별도의 객체라고 생각하면 이해하기 쉽다. 6. === 은 항상 객체의 주소 값만을 비교한다. 다른 것과 같이 묶어서 생각할 필요가 없다. 명확하게 별도의 기능이기 때문이다.