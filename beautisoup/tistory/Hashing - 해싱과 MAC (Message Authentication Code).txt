1. 해싱은 Checksum, Fingerprint, Hash, CRC 같은 용어로도 불린다. 1-1 해싱은 메시지를 특정한 방식으로 계산하여 만든 메시지 정보를 저장하지 않는 결과 값이다. 1-2 원본의 정보를 저장하지 않기 때문에 해싱값으로는 원본을 복구할 수 없다. 2. 해싱 알고리즘 요구사항 2-1 특정한 해싱 결과를 임의로 계산하여 만들 수 없다. 2-2 해시 값으로 원 메시지를 추출할 수 없다. 단 방향이다. 2-3 작은 변화가 전체 값을 바꿔야 한다. 2-4 정해진 길이의 값을 반환해야 한다. 3. Collision - 필연적인 현상 3-1 두 다른 메시지가 같은 동일한 결과를 가질 때 3-2 길이가 지정되어 있기 때문에 어떻게든 중복이 일어날 수 밖에 없다. 3-3 따라서 길이가 길수록 안전하다. 3-4 MD5 128bits, SHA1 160bits, SHA2 -> 224, 256, 384, 512 bits 4. Data Integrity 보장 4-1 데이터가 조금이라도 변할 경우 해시가 맞지 않는다. (Integrity) 4-2 데이터 통신 시에 데이터와 해싱을 같이 보낸다. 4-3 문제는 중간에 가로채서 새로운 메시지를 해싱해서 보낼 수도 있다는 점이다. 이러면 메시지와 해싱 값이 일치한다. 4-3-0 이 문제를 해결하기 위한 결과물이 HMAC이다. 4-3-1 대칭키를 공유하여 대칭키와 메시지를 같이 해싱한 결과(해시값)를 메시지와 보낸다. 4-3-1-1 MAC (Message Authentiation Code) - 메시지 + 대칭키 -> 해싱 -> 해시 값 4-3-1-2 메시지, 키를 결합하는 순서도 중요하다. 순서가 바뀌면 해시값도 바뀐다. 4-3-1-3 => RFC 2014 HMAC (Hash Based Message Authentication Code) 4-3-1-3-1 국제 표준으로 지정된 메시지, 키 결합 및 순서를 지정한 규약 4-3-2 받는 측에서 대칭키와 메시지로 해싱하여 Integrity를 확인할 수 있다. 4-3-3 문제는 어떻게 대칭키를 공유할지다. (Authentication)