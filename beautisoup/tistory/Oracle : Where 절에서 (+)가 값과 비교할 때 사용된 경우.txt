1. 내가 젤 하기 싫어하고 잘 하지도 못하는 부분이 SQL이다. 사실 하기 싫은 것 보다는 웬만하면 어플리케이션 쪽에서 로직을 처리하도록 프로그램을 작성하는 편이다. 내가 경험해 온 국내의 대부분의 대용량 시스템은 데이터베이스에 너무 종속되어 거의 모든 컴퓨팅 자원이 데이터베이스에 몰려 있다. 일반적으로 DB 98%, AP 2% 정도 되는 것 같다. 2. 우리나라 개발자들은 알고리즘을 상당히 두려워한다. 그래서 복잡한 데이터베이스 쿼리로 처리하려고 하는 것 같은데 나에게는 너무 놀라운 현상이다. 복잡한 쿼리를 잘 작성하고 이해할 정도면 프로그램은 사실 식은 죽먹기 수준이기 때문이다. 3. 아무튼 현업에서는 대용량 데이터베이스를 주로 다루기 때문에 오라클이 항상 주력인데 한번씩 헷갈리는 부분이라 메모한다. 3-1 아래의 코드는 단순화 한 LEFT OUTER JOIN이지만 일반적으로는 적게는 10개 많게는 30개 정도의 테이블이 조인된 쿼리가 많다. 3-2 조인 테이블이 많아지는 것은 좋은데 하나의 업무 처리처럼 A, B, C, D 같이 순차적으로 처리되는 업무의 처리 단계를 조회하려고 할 때는 A 테이블을 기준으로 연관관계 테이블을 참조하여 OUTER JOIN을 사용하게 된다. 3-3 이처럼 A 테이블을 기준으로 처리현황을 보려 테이블을 조인한 후 필요한 것을 뽑아 내기 위해서 제약조건을 걸어야 하는데, 오라클의 (+) 문법은 엄청한 혼란을 초래한다. 3-4 위의 설명과는 상관없이 고객과 주문 테이블로 간단히 설명하면, 아래의 O.STATUS(+) = 'P' 구문은 정말 혼동스럽다. 무엇을 하라는지 알기 힘들다. 아래의 구문은 한 고객이 진행중인 주문이 없거나 하나만 있다고 가정한다. SELECT	*
FROM	CUSTOMER C, ORDER O
WHERE	C.IDX_CUST = O.IDX_CUST(+)
    AND	C.ACTIVE = 'Y'
    AND O.STATUS(+) = 'P' 3-5 결론만 말하면 ANSI 문법을 사용하고 (+) 문법을 피하라는 조언을 반복할 수 밖에 없다. 3-6 아래의 쿼리처럼 (+) 가 붙은 부분은 OUTER JOIN의 일부로 포함되어 연산된다. 3-7 아래의 경우는 3-7-1 우선 조인절에서 모든 고객에 대해서 고객번호를 키로 진행 중인 주문을 같이 보여주는데 진행 중인 주문이 없는 고객도 화면에 보여지게 된다. 진행 중인 주문의 없는 고객의 주문은 NULL 표시된다. 전체에서 보여지는 O.STATUS는 'N', 'D' 같은 다른 경우는 나오지 않고 P나 NULL 두 가지 밖에 없다. 3-7-2 다음 순서로 WHERE 절에서는 3-7-1로 추출된 결과물에서 현재 활동 중인 고객 만 필터가 되어 정지 되거나 사용하지 않는 고객은 결과물에서 사라지게 된다. 3-7-3 위의 오라클 SQL과 동일한 ANSI SQL이다. SELECT	*
FROM	CUSTOMER C LEFT OUTER JOIN ORDER O ON C.IDX_CUST = O.IDX_CUST AND O.STATUS = 'P'
WHERE	C.ACTIVE = 'Y' 3-8 O.STATUS(+) = 'P' 에서 (+)가 없어지는 경우는 이 구문이 WHERE 절에 단순히 포함되기 때문에 진행 중인 주문이 없는 고객은 필터되어 아예 나오지 않게 된다. 결국 진행 중인 주문이 있는 고객과 주문 상태 P인 주문 만 표출된다.