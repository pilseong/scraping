1. 인터페이스에는 불필요한 메소드가 있어서는 안된다. 2. 필요한 기능에 맞는 인터페이스를 여러 개 생성하는 것이 모든 메소드를 다 가지는 인터페이스보다 낫다. 3. 아래는 지난 Open Close 원리에서 붙였던 도면을 여기에도 가져다 쓰고 있다. 3-1 아래의 도식 역시 Interface segregation의 원칙이 반영되어 있다. 3-2 FlyBehavior, QuackBehavior라는 두개의 별도의 기능을 가지는 인터페이스를 사용하고 있기 때문이다. 4. 하지만 아래의 예제의 경우, Duck 클래스는 두 개의 인터페이스를 구현한 객체를 소유하는 형식으로 구현한다. 4-1 즉 Duck 클래스가 가지는 기능의 형태를 다양한 방식으로 확장하고 있는 것이지 4-2 Duck 자체의 기능을 추가하는 방식은 아니다. 5. 인터페이스 분리의 원칙을 더 명확하게 보이는 예제는 아래의 그림이 더 적절해 보인다. 5-1 고속도로와 주차장에서 has하고 있는 Vehicle은 다른 기능을 요구하고 있고 적절한 경우로 구현할 수 있다. 6. 아래의 그림도 Pet이라는 인터페이스를 확장하여 PetDogs, PetCats라는 인터페이스를 생성하고 있다. 6-1 개와 고양이는 Pet 뿐 아니라 PetDogs, PetCats를 확장해야 한다. 6-2 이 방식은 수직적인 구조를 가지고 있어서 부모 인터페이스의 기능을 모두 구현해야 한다. 6-3 수평적인 구조로도 인터페이스를 만들 수 있는데 이는 7번 항목을 참고한다. 7. 수평적 구조로 여러 개 인터페이스를 조합하여 새로운 용도의  인터페이스를 만들 수 있다. 7-1 스프링 프레임워크 라이브러리 구현에 상당히 많이 사용되고 있다. 7-2 동물 인터페이스와 애완동물 인터페이스를 상속하여 dog인터페이스를 만들 수 있다.