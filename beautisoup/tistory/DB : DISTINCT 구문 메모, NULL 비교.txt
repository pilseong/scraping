1. Distinct는 Select 절에서 사용되는 중복 제거 구문이다. 2. 우선 SQL 구문의 처리 순서를 알 필요가 있는데 2-1 FROM -> ON -> OUTER -> WHERE -> GROUP BY -> CUBE, ROLLUP, HAVING -> SELECT -> DISTINCT -> 2-2 ORDER BY -> LIMIT, TOP 3. 내부적인 처리 방식은 SELECT로 가져온 모든 대상 결과물을 가지고 DISTINCT 대상이 되는 컬럼(들)로 정렬을 한 후, 앞뒤로 동일한지를 비교해서 동일한 대상 컬럼의 경우 삭제를 한다. 대상 컬럼으로 정열이 되기 때문에 부하가 있는 작업이다. ORDER BY는 DISTINCT 뒤에 수행되기 때문에 DISTINCT로 정리된 결과물을 다시 정렬하게 된다. 4. DISTINCT가 하나의 컬럼에만 지정되는 경우, 그 해당 컬럼으로 정렬한 후 비교한다. SELECT에 하나 이상의 컬럼이 있는데 특정하나의 컬럼에 DISTICT를 지정하면 SELECT에 지정된 모든 컬럼의 결과를 합하여 정렬하여 비교하게 된다. 즉 DISTINCT 구문 다음에 지정된 컬럼만 DISTINCT의 대상이 되는 것이 아니라는 의미가 된다. 4-1 아래의 구문은 job_id 와 salary 결과를 더 하여 각 record의 중복을 비교한다. SELECT	DISTINCT job_id, salary
FROM	EMPLOYEES
ORDER BY job_id, salary 5. 그러면 NULL은 어떻게 처리가 될지가 궁금하다. NULL은 기본적으로 == 가 성립되지 않는다. 그래서 NULL 기본적으로 모든 다른 값이다. 하지만 DISTINCT에서는 모든 NULL은 동일하게 취급하여 하나의 NULL만으로 표기된다. 6. NULL 비교에 대해서 한 가지 기억해야 할 것은 WHERE절에서 비교연산자 사용시 NULL을 값으로 사용하면 안된다는 점이다. 6-0 기본적으로 비교 연산은 두 개의 NULL이 아닌 값을 비교하는 것이기 때문에 NULL과의 비교는 false가 반환된다. 6-1 = 연산이라면 값이 NULL인 것들을 가지고 오는 것이 아니라 항상 false의 결과를 돌려 주기 때문에 사용할 수가 없다. 6-2 기본적으로 비교 연산의 결과는 true, false, unknown이다. 여기에서는 항상 false가 반환되어 결과가 항상 나오지 않는다. 6-3 값이 NULL인 것을 가지고 오려는 경우는 is NULL을 사용해야 한다. 6-4 <>, != 연산도 마찬가지로 NULL이 들어 있는 셀의 경우는 false가 반환되기 때문에 결과값에 포함되지 않는다. 7. 비교연산자와 NULL 구문의 관계는 일반적으로 8. 상관없는 내용이지만 postgresql의 날짜 차이를 구하는 구문을 메모해 둔다. datediff 함수가 없다. SELECT	employee_id, first_name, last_name,
  extract(day from to_timestamp('2015-01-01', 'YYYY-MM-DD') - 
              to_timestamp(hire_date as text), 'YYYY-MM-DD'))
FROM 	EMPLOYEES