0. 여기에서는 Spring Cloud Gateway를 생성한다. 0-1 Gateway를 확장해서 다양한 filter를 생성하거나 캐시를 이용한 인증 같은 것들을 부가적으로 구현할 수 있겠지만 0-2 여기는 아주 간단한 Gateway를 만든다. 0-3 나중에 로그인과 가입을 제외한 나머지 호출에 JWT를 검증하는 필터를 작성하겠지만 0-4 복잡성을 줄이기 위해 Routing을 위해 predicate, filter는 application.properties에서 정의하는 방식으로 작성한다. 1. Gateway의 기능은 말 그대로 외부에서 오는 request를 유레카 서버의 등록된 서비스 정보를 가지고 서비스를 검색한다. 1-1 특징을 나열해 보면 1-2 Spring WebFlux기반이라서 Reactive Programming으로 개발해야 한다. 1-3 스프링 5.0, 스프링 2.0에서 처음으로 도입되었다. 1-4 특정 경로(route)를 설정하기 위해서 predicates, filters를 사용하는데 1-4-1 Predicates는 조건에 맞는 경로의 요청인지를 판단하여 특정 경로로 안내한다. 1-4-2 filters는 해당 요청을 우선 처리해서 헤더를 가공하거나 gateway 통과여부 등을 결정한다. MVC의 filter와 거의 같다. 1-5 Circuit breaker 내장 - 이건 중단 시 예외 처리 루틴 같은 것으로 보면 된다. 1-6 쉬운 Predicates, Filters 작성 - Reactive 프로그래밍을 잘 알면 쉽다. 선택가능한 기본 Predicates, Filters도 많다. 1-7 Request의 속도 조절 1-8 경로 재설정 - A라는 경로로 왔지만 B로 보내거나 이런 거 같은 거다. 경로에서 마이크로서비스 이름을 제거할 수도 있다. 1-9 아래의 Gateway Handler Mapping이 route 결정하는 부분, 즉 predicate를 거쳐 서비스를 결정하는 부분이고 1-10 결정된 경로를 Gateway Web Handler가 필터를 거처 서비스 프로시를 통해 실제 경로인 마이크로서비스로 전달한다. 2. 프로젝트를 적절하게 생성한다. 2-2 gateway starter, eureka client 만 있으면 기본적인 것은 동작한다. 3. application.properties 설정 3-1 마이크로서비스가 아직 없기 때문에 접속할 유레카 서버 경로를 지정하는 정도가 의미가 있다. 3-2 spring.cloud.gateway.discovery.locator.enabled=true는 3-2-1 유레카 서버로 부터 받은 서비스 등록정보를 가지고 경로를 동적으로 만들어 준다. 우선 이걸로 설정한다. https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-discoveryclient-route-definition-locator 3-3 아래 설정의 제일 마지막 부분 lower-case-service-id=true는 3-3-1 기본적으로 대문자로 설정된 서비스 이름을 소문자 경로로 변경한다. 나는 가독성이 떨어져 사용하지 않는다. server.port=8081
spring.application.name=apigateway

eureka.client.service-url.defaultZone=http://admin:admin@localhost:8761/eureka

spring.cloud.gateway.discovery.locator.enabled=true
#spring.cloud.gateway.discovery.locator.lower-case-service-id=true 4. 두 개의 만들어진 서비스 폴더들이다 4-1 별 내용이 없지만 두 서버가 돌아가고 있다. 5. 테스트 5-1 에러없이 잘 붙고 잘 돌아간다. 8081번에서 돌아가고 있는 apigateway가 등록된 것을 확인할 수 있다.