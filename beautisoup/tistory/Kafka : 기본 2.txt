1. 용어(계속) 1-1 Consumers : 데이터를 받기를 원하는 클라이언트 1-1-1 컨슈머는 브로커가 죽어도 어떤 브로커가 리더인지 알 수 있다. 1-1-2 특정 파티션 내의 데이터의 순서는 항상 유지 된다. 1-2 Consumer Group : 컨슈머의 집합으로 특정한 토픽의 데이터를 받는다. 1-2-1 그룹 내에서 하나의 컨슈머는 다른 컨슈머와는 다른 파티션을 읽는다. 1-2-2 컨슈머가 파티션보다 많으면 남은 컨슈머는 논다. 1-2-3 아래 그림의 C는 컨슈머인데 그룹 A는 3개, 그룹 B는 2개의 컨슈머를 가진다. 1-2-3-1 각 컨슈머는 그림처럼 각기 다른 파티션을 읽고 있다. 1-2-3-2 그룹 B는 토픽 B의 파티션이 하나 뿐이므로 하나의 컨슈머는 논다. 1-2-4 컨슈머는 GroupCoordinator, ConsumerCoordinator를 통해 자동으로 파티션을 할당 받는다. 1-3 Consumer Offset : 이건 컨슈머가 어디까지 데이터를 읽었는지 카프카에 표시를 하는 것이다. 1-3-0 이 정보는 카프카 내의 __consumer_offsets 이라는 토픽에 저장된다. 1-3-1 즉 해당 offset까지 읽었으니 다음 부터 읽을 수 있다. offset은 물론 파티션 내에서만 의미가 있다. 1-3-2 컨슈머가 죽으면 다른 컨슈머나 재기동 된 컨슈머는 이 정보를 통해 읽기 시작 위치를 알 수 있다. 1-3-3 컨슈머가 언제 offset을 커밋(확정)할지에 대한 3가지 기법이 있다. 1-3-3-1 At most once : 컨슈머가 데이터를 받은 즉시 offset을 지정한다. 문제가 생기면 다시 못받는다. 1-3-3-2 At least once : 메시지를 처리한 후에 offset을 설정한다. 문제가 생기면 다시 읽을 수 있다. 1-3-3-2-1 중복 처리 시 컨슈머 상태가 문제가 될 수 있으니 idempotent를 보장해야 한다. 1-3-3-3 Exactly once : 한번 읽었을 때 처리되는 것을 보장한다. 1-3-3-3-1 Kafka Streams API를 통해 카프카에서 카프카로 전송할 때 가능하다. 1-3-3-3-2 외부 시스템 일 경우는 idempotent 컨슈머를 사용해야 한다. 1-4 Kafka Broker Discovery : 어떻게 브로커 서버가 외부(producer, consumer)에게 알려지는지에 관한 기술이다. 1-4-1 모든 브로커들은 bootstrap server이다. 이 말은 어떤 놈에게 붙어도 모든 브로커 정보를 받을 수 있다는 의미 1-4-2 한 놈에게 붙으면 접속된 브로커로 부터 메타데이터를 받아와 추후에 다른 브로커에 접속할 때 사용할 수 있다. 1-5 Zookeeper : 카프카 브로커를 관리하는 서비스 즉 메타데이터를 관리한다. - 역시 클러스터를 구성할 수 있다. 1-5-1 leader를 뽑을 필요가 있을 때 도움을 준다. 1-5-2 카프카 내부정보가 변경된 경우 카프카에게 알림을 보내 준다. 1-5-2-1 예를 들면, 새로운 토픽 생성 및 삭제, 브로커가 죽은 경우, 브로커의 기동 등 1-5-3 주키퍼 없이는 카프카는 동작하지 않는다. 1-5-4 주키퍼의 클러스터는 홀수만 직원한다. 즉 3대, 5대, 7대 같은 수의 서버로만 클러스터를 만든다. 1-5-5 주키퍼 내에도 리더가 있고 나머지는 follower들이 있다. 리더만 데이터를 쓸 수 있고 나머지는 읽기만 지원 1-5-6 주키퍼는 consumer offset을 저정하지 않는다. (예전버전에는 저장했음) 완전독립적으로 동작한다. 2. 카프카가 보장하는 것들 2-1 토픽의 파티션 내에는 메시지의 순서가 보장된다. 컨슈머가 토픽 파티션 내의 메시지는 저장순서대로 읽게 된다. 2-2 replication factor가 N이면 N-1개의 서버가 죽어도 동작한다. 보통 3을 권장한다. 2-3 파티션의 수가 고정될 경우, 같은 키값을 가진 메시지는 같은 브로커, 즉 같은 파티션에 저장된다.